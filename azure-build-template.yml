# azure-build-template.yml
# Template for the build jobs that we want to run in the pipeline in Azure Dev Ops. This template is
# instantiated in azure-pipelines.yml. For more information on templates, see
# https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops


parameters:
- name: hostos
  type: string
  values:
  - Windows
  - Linux
- name: env
  type: string
  values:
  - WindowsUserMode
  - LinuxUserMode
  - Generic
- name: arch
  type: string
  values:
  - AMD64
  - X86
  - ARM64
  - ARM
  - Unknown
- name: cc
  type: string
  values:
  - cl
  - gcc
  - clang
- name: cxx
  type: string
  values:
  - cl
  - g++
  - clang++
- name: buildType
  type: string
  values:
  - Debug
  - Release
  - Sanitize
- name: additionalCMakeArgs
  type: string
  default: ''

steps:
  - checkout: self  # self represents the repo where the initial Pipelines YAML file was found
    submodules: recursive
  # Initialize CMake
  # cd bin; cmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake-toolchain/{env}-{arch}.cmake -DCMAKE_C_COMPILER={CC} -DCMAKE_BUILD_TYPE={buildType} {additionalCMakeArgs}'
  - task: ComponentGovernanceComponentDetection@0
  - ${{ if eq(parameters.env, 'LinuxUserMode') }}:
    - script: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r $(Build.SourcesDirectory)/scripts/requirements.txt
      displayName: 'Install Python requirements'
  # Specify no toolchain file for generic build
  - ${{ if eq(parameters.env, 'Generic') }}:
    - task: CMake@1
      inputs:
        workingDirectory: '$(Build.SourcesDirectory)/bin'
        cmakeArgs: >-
          ..
          -DCMAKE_C_COMPILER=${{parameters.cc}} -DCMAKE_CXX_COMPILER=${{parameters.cxx}}
          -DCMAKE_BUILD_TYPE=${{parameters.buildType}}
          ${{parameters.additionalCMakeArgs}}
  # Specify toolchain file based on env and arch for non-generic build
  - ${{ if ne(parameters.env, 'Generic') }}:
    - task: CMake@1
      inputs:
        workingDirectory: '$(Build.SourcesDirectory)/bin'
        cmakeArgs: >-
          ..
          -DCMAKE_TOOLCHAIN_FILE=../cmake-toolchain/${{parameters.env}}-${{parameters.arch}}.cmake
          -DCMAKE_C_COMPILER=${{parameters.cc}} -DCMAKE_CXX_COMPILER=${{parameters.cxx}}
          -DCMAKE_BUILD_TYPE=${{parameters.buildType}}
          ${{parameters.additionalCMakeArgs}}
  # Build with CMake
  # cmake --build . -j
  - ${{ if eq(parameters.hostos, 'Windows') }}:
    - task: CMake@1
      inputs:
        workingDirectory: '$(Build.SourcesDirectory)/bin'
        cmakeArgs: '--build . -j --config ${{parameters.buildType}}'
    # Execute unit tests using the inline script
    - ${{ if ne(parameters.env, 'Generic') }}:
      - script: |
          cd bin\exe\${{parameters.arch}}\${{parameters.env}}\${{parameters.buildType}}
          .\symcryptunittest.exe
        displayName: 'Execute unit tests'
        name: '${{parameters.env}}UnitTest_${{parameters.buildType}}'
    - ${{ if eq(parameters.env, 'Generic') }}:
      - script: |
          cd bin\exe\%PROCESSOR_ARCHITECTURE%\${{parameters.env}}\${{parameters.buildType}}
          .\symcryptunittest.exe
        displayName: 'Execute unit tests'
        name: '${{parameters.env}}UnitTest_${{parameters.buildType}}'
  - ${{ if eq(parameters.hostos, 'Linux') }}:
    - task: CMake@1
      inputs:
        workingDirectory: '$(Build.SourcesDirectory)/bin'
        cmakeArgs: '--build . -j'
    # Increase ulimit to enable core dump in case of a test crash
    - script: |
        ulimit -c unlimited
      displayName: 'Enable core dumps'
    # Execute module and unit test using the inline script
    - ${{ if ne(parameters.env, 'Generic') }}:
      - script: |
          cd bin/exe/${{parameters.arch}}/${{parameters.env}}
          ulimit -c unlimited
          ./symcryptunittest
        displayName: 'Execute unit tests'
        name: '${{parameters.env}}UnitTest_${{parameters.buildType}}'
      - ${{ if ne(parameters.buildType, 'Sanitize') }}:
        # Only run module test if rdseed is present on the CPU
        - script: |
            cd bin/exe/${{parameters.arch}}/${{parameters.env}}
            if lshw -c cpu | grep -q rdseed
            then ./symcryptmoduletest
            fi
          displayName: 'Execute module test'
    # Execute unit test using the inline script
    - ${{ if eq(parameters.env, 'Generic') }}:
      - script: |
          archName=`uname -m`
          cd bin/exe/${archName}/${{parameters.env}}
          ./symcryptunittest
        displayName: 'Execute unit tests'
        name: '${{parameters.env}}UnitTest_${{parameters.buildType}}'
  # Publish artifacts so they're available in the pipeline results
  - publish: $(System.DefaultWorkingDirectory)/bin
    artifact: 'drop-${{parameters.hostos}}-${{parameters.env}}-${{parameters.arch}}-${{parameters.cc}}-${{parameters.buildType}}-${{parameters.additionalCMakeArgs}}'
  # Publish artifacts, core dumps and temporary files on failure
  - publish: $(System.DefaultWorkingDirectory)/bin
    artifact: 'failed-${{parameters.hostos}}-${{parameters.env}}-${{parameters.arch}}-${{parameters.cc}}-${{parameters.buildType}}-${{parameters.additionalCMakeArgs}}'
    condition: failed()
  - publish: $(Agent.TempDirectory)
    artifact: 'temp-${{parameters.hostos}}-${{parameters.env}}-${{parameters.arch}}-${{parameters.cc}}-${{parameters.buildType}}-${{parameters.additionalCMakeArgs}}'
    condition: failed()
  - publish: $(Agent.WorkFolder)
    artifact: 'work-${{parameters.hostos}}-${{parameters.env}}-${{parameters.arch}}-${{parameters.cc}}-${{parameters.buildType}}-${{parameters.additionalCMakeArgs}}'
    condition: failed()